
<html><head>
  <title>Hyperbolic Tessellator</title>
  <style>
   body {
     margin: 0;
   }
  </style>
  <script src="./scripts/main.js" type="text/javascript"></script>

  <script id="vs" type="x-shader/x-vertex">
   attribute vec3 position;

   void main(void){
     gl_Position = vec4(position, 1.0);
   }
  </script>

  <script id="fs" type="x-shader/x-fragment">
   precision mediump float;

   uniform float iGlobalTime;
   uniform vec2 iResolution;
   uniform vec2 camResolution;
   uniform sampler2D texture;

   vec2 rand2n(vec2 co, float sampleIndex) {
     vec2 seed = co * (sampleIndex + 1.0);
     seed+=vec2(-1,1);
     // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
     return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
   }

   vec2 tp1 = vec2(0.26607724, 0);
   vec2 tp2 = vec2(0, 0.14062592);
   vec2 cPos = vec2(2.01219217, 3.62584500);
   float r = 4.02438434;
   const float PI = 3.14159265359;

   void calcCircle(float theta, float phi){
     float tanTheta = tan(PI/2. - theta);
     float tanPhi = tan(phi);
     float tanTheta2 = tanTheta * tanTheta;
     float tanPhi2 = tanPhi * tanPhi;

     tp1 = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)) -
                tanTheta * sqrt((1. + tanPhi2)/(-tanPhi2 + tanTheta2))/tanTheta, 0.);
     tp2 = vec2(0., -tanPhi * sqrt(-(1. + tanTheta2)/(tanPhi2 - tanTheta2))+
                                                      tanTheta * sqrt(-(1. + tanPhi2)/(tanPhi2 - tanTheta2)));


     cPos = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)),
                 sqrt((1. + tanPhi2)*tanTheta2/(-tanPhi2 + tanTheta2)));
     r = sqrt((1. + tanPhi2)*(1. + tanTheta2) /(-tanPhi2 + tanTheta2));
   }

   vec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){
     return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;
   }

   const int ITERATIONS = 50;
   float loopNum = 0.;
   vec2 g_pos;
   int IIS(vec2 pos){
//     if(length(pos) > 1.) return 0;

     int invCount = 1;
     bool fund = true;
     for(int i = 0 ; i < ITERATIONS ; i++){
       fund = true;
       // if (pos.x < 0.){
       //   pos *= vec2(-1, 1);
       //   invCount++;
       //   fund = false;
       // }
       // if(pos.y < 0.){
       //   pos *= vec2(1, -1);
       //   invCount++;
       //   fund = false;
       // }
       if(distance(pos, cPos) < r && pos.x > 0. && pos.y > 0.){
         pos = circleInverse(pos, cPos, r);
         invCount++;
         fund = false;
       }else if(distance(pos, -cPos) < r && pos.x < 0. && pos.y < 0.){
         pos = circleInverse(pos, -cPos, r);
         invCount++;
         fund = false;
       }else if(distance(pos, vec2(-cPos.x, cPos.y)) < r && pos.x < 0. && pos.y > 0.){
         pos = circleInverse(pos, vec2(-cPos.x, cPos.y), r);
         invCount++;
         fund = false;
       }else if(distance(pos, vec2(cPos.x, -cPos.y)) < r && pos.x > 0. && pos.y < 0.){
         pos = circleInverse(pos, vec2(cPos.x, -cPos.y), r);
         invCount++;
         fund = false;
       }
       if(fund){
         g_pos = pos;
         return invCount;
       }
     }

     g_pos = pos;
     return invCount;
   }

   vec3 hsv2rgb(vec3 c)
   {
     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
   }

   const float sampleNum = 50.;
   void main(){
     float ratio = iResolution.x / iResolution.y / 2.0;
     vec3 sum = vec3(0);
     calcCircle(PI/(4. + sin(iGlobalTime)), PI/8.);
     vec2 translate = vec2(tp1.x, tp2.y);
     vec2 tile = vec2(tp1.x, tp2.y) * 2.;

     for(float i = 0. ; i < sampleNum ; i++){
       vec2 position = ( (gl_FragCoord.xy + rand2n(gl_FragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);

       position = position * 2.;
       //position *= 1./ iGlobalTime;//0.03 + abs(1. * sin(iGlobalTime) * sin(iGlobalTime));
       //position *= 2. + abs(1. * sin(iGlobalTime) * sin(iGlobalTime));
       position *= 1.0;
       //position +=vec2(1., 0.);// vec2(cos(iGlobalTime), 0.3 * sin(iGlobalTime));

       int d = IIS(position);

       if(d == 0){
         sum += vec3(0.,0.,0.);
       }else{
         if(distance(g_pos, cPos) - r < 0.01 ||
            distance(g_pos, -cPos) - r < 0.01 ||
            distance(g_pos, vec2(-cPos.x, cPos.y)) - r < 0.01 ||
            distance(g_pos, vec2(cPos.x, -cPos.y)) - r < 0.01){
              sum += vec3(1., 0, 0);
            }else{
              vec2 translate = vec2(tp1.x, tp2.y);
              sum += texture2D(texture, abs( vec2(0., 1.) - (g_pos + translate) / tile)).rgb;
            }
         // if(mod(float(d), 2.) == 0.){
         //    sum += hsv2rgb(vec3(0.3, 1., 1.));
         //  }else{
         //    sum += hsv2rgb(vec3(0.7, 1., 1.));
         //  }
       }
     }
     gl_FragColor = vec4(sum/sampleNum, 1.);
   }
  </script>
  <script id="fs2" type="x-shader/x-fragment">
   precision mediump float;

   uniform float iGlobalTime;
   uniform vec2 iResolution;
   uniform vec2 camResolution;
   uniform sampler2D texture;

   vec2 tp1 = vec2(0.26607724, 0);
   vec2 tp2 = vec2(0, 0.14062592);
   vec2 cPos = vec2(2.01219217, 3.62584500);
   float r = 4.02438434;
   const float PI = 3.14159265359;

   void calcCircle(float theta, float phi){
     float tanTheta = tan(PI/2. - theta);
     float tanPhi = tan(phi);
     float tanTheta2 = tanTheta * tanTheta;
     float tanPhi2 = tanPhi * tanPhi;

     tp1 = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)) -
                tanTheta * sqrt((1. + tanPhi2)/(-tanPhi2 + tanTheta2))/tanTheta, 0.);
     tp2 = vec2(0., -tanPhi * sqrt(-(1. + tanTheta2)/(tanPhi2 - tanTheta2))+
                                                      tanTheta * sqrt(-(1. + tanPhi2)/(tanPhi2 - tanTheta2)));


     cPos = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)),
                 sqrt((1. + tanPhi2)*tanTheta2/(-tanPhi2 + tanTheta2)));
     r = sqrt((1. + tanPhi2)*(1. + tanTheta2) /(-tanPhi2 + tanTheta2));
   }

   void main(){
     float ratio = iResolution.x / iResolution.y / 2.0;
     vec3 sum = vec3(0);
     calcCircle(PI/(4. + sin(iGlobalTime)), PI/8.);

     vec2 position = ( (gl_FragCoord.xy) / iResolution.yy ) - vec2(ratio, 0.5);

     position = position * 2.;
     // position *= 1./ iGlobalTime;//0.03 + abs(1. * sin(iGlobalTime) * sin(iGlobalTime));
     position *= 1.0;
     //position +=vec2(1., 0.);// vec2(cos(iGlobalTime), 0.3 * sin(iGlobalTime));
     vec2 translate = vec2(tp1.x, tp2.y);
     position += translate;
     vec2 tile = vec2(tp1.x, tp2.y) * 2.;
     if(0. < position.x && position.x < tile.x &&
        0. < position.y && position.y < tile.y ){
          gl_FragColor = texture2D(texture, abs( vec2(0., 1.) - (position) / tile));
        }
   }

  </script>
  <script id="fs3" type="x-shader/x-fragment">
   precision mediump float;

   uniform float iGlobalTime;
   uniform vec2 iResolution;
   uniform vec2 camResolution;
   uniform sampler2D texture;

   vec2 rand2n(vec2 co, float sampleIndex) {
     vec2 seed = co * (sampleIndex + 1.0);
     seed+=vec2(-1,1);
     // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
     return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
   }


   vec2 cPos1 = vec2(1.2631, 0);
   vec2 cPos2 = vec2(0, 1.2631);
   float cr1 = 0.771643;
   float cr2 = 0.771643;
   const float PI = 3.14159265359;

   vec2 g_pos;

   vec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){
     return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;
   }

   vec2 reverseStereoProject(vec3 pos){
     return vec2(pos.x / (1. - pos.z), pos.y / (1. - pos.z));
   }

   vec4 circleIntersection(vec2 cPos1, float r1, vec2 cPos2, float r2){
     float x = cPos1.x - cPos2.x;
     float y = cPos1.y - cPos2.y;
     float x2 = x * x;
     float y2 = y * y;
     float x2y2 = x2 + y2;
     float a = (x2y2 + r2 * r2 - r1 * r1) / 2.;
     float a2 = a * a;
     float numR = sqrt(x2y2 * r2 * r2 - a2);
     return vec4((a * x + y * numR) / x2y2 + cPos2.x, (a * y - x * numR) / x2y2 + cPos2.y,
                 (a * x - y * numR) / x2y2 + cPos2.x, (a * y + x * numR) / x2y2 + cPos2.y);
   }

   vec3 stereoProject(vec2 pos){
     float x = pos.x;
     float y = pos.y;
     float x2y2 = x * x + y * y;
     return vec3((2. * x) / (1. + x2y2),
                 (2. * y) / (1. + x2y2),
                 (-1. + x2y2) / (1. + x2y2));
   }

   vec3 getCircleFromSphere(vec3 upper, vec3 lower){
     vec2 p1 = reverseStereoProject(upper);
     vec2 p2 = reverseStereoProject(lower);
     return vec3((p1 + p2) / 2., distance(p1, p2)/ 2.);
   }

   bool revCircle = false;
   bool revCircle2 = false;
   const int ITERATIONS = 50;
   float colCount = 0.;
   bool outer = false;
   int IIS(vec2 pos){
     colCount = 0.;
     //if(length(pos) > 1.) return 0;

     bool fund = true;
     int invCount = 1;
     for(int i = 0 ; i < ITERATIONS ; i++){
       fund = true;
       // if (pos.x < 0.){
       //   pos *= vec2(-1, 1);
       //   invCount++;
       //   fund = false;
       // }
       // if(pos.y < 0.){
       //   pos *= vec2(1, -1);
       //   invCount++;
       //   fund = false;
       // }
       if(revCircle){
         if(distance(pos, cPos1) > cr1 ){
           pos = circleInverse(pos, cPos1, cr1);
           invCount++;
           colCount++;
           fund = false;
         }
          if(distance(pos, -cPos1) > cr1 ){
            pos = circleInverse(pos, -cPos1, cr1);
            invCount++;
            colCount++;
            fund = false;
          }
       }else{
         if(distance(pos, cPos1) < cr1 ){
           pos = circleInverse(pos, cPos1, cr1);
           invCount++;
           colCount++;
           fund = false;
         }
         if(distance(pos, -cPos1) < cr1 ){
            pos = circleInverse(pos, -cPos1, cr1);
            invCount++;
            colCount++;
            fund = false;
          }
       }

       if(revCircle2){
         if(distance(pos, cPos2) > cr2 ){
           pos = circleInverse(pos, cPos2, cr2);
           invCount++;
           colCount++;
           fund = false;
         }
          if(distance(pos, -cPos2) > cr2 ){
            pos = circleInverse(pos, -cPos2, cr2);
            invCount++;
            colCount++;
            fund = false;
          }
       }else{
         if(distance(pos, cPos2) < cr2 ){
           pos = circleInverse(pos, cPos2, cr2);
           invCount++;
           colCount++;
           fund = false;
         }
         if(distance(pos, -cPos2) < cr2 ){
            pos = circleInverse(pos, -cPos2, cr2);
            invCount++;
            colCount++;
            fund = false;
          }
       }

       if(fund){
         if(length(pos) > 1.5){
           outer = true;
           return 0;
         }
         g_pos = pos;
         return invCount;
       }
     }

     g_pos = pos;
     return invCount;
   }

   vec3 hsv2rgb(vec3 c)
   {
     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
   }

   vec3 calcCircleFromLine(vec4 line){
     float a = line.x;
     float b = line.y;
     float c = line.z;
     float d = line.w;

     float bcad = b * c - a * d;
     float a2 = a * a;
     float b2 = b * b;
     float c2 = c * c;
     float d2 = d * d;
     float c2d2 = (1. + c2 + d2);
     vec2 pos = vec2(((1. + a2) * d + b2 * d - b * c2d2)/(-2. * bcad),
                     (a2 * c + (1. + b2) * c - a * c2d2)/ (2. * bcad));
     return vec3(pos, distance(pos, line.xy));
   }

   const float sampleNum = 10.;
   void main( ){

     float t = mod(iGlobalTime, 10.);
     t = abs(t - 5.) / 5.;

     float ratio = iResolution.x / iResolution.y / 2.0;
     vec3 sum = vec3(0);
     float x = 0.57735;

     float bendX = t;// 0. + 1. * abs(sin(iGlobalTime));;//PI / 6.;
     mat3 xRotate = mat3(1, 0, 0,
                         0, cos(bendX), -sin(bendX),
                         0, sin(bendX), cos(bendX));
     float bendY = 0.;//PI/6.5;//-abs(0.8 * sin(iGlobalTime));
     mat3 yRotate = mat3(cos(bendY), 0, sin(bendY),
                         0, 1, 0,
                         -sin(bendY), 0, cos(bendY));
     float y = .57735;
     vec3 c1 = getCircleFromSphere(vec3(0, y, sqrt(1. - y * y))* xRotate,
                                   vec3(0, y, -sqrt(1. - y * y))* xRotate);
     vec3 c2 = getCircleFromSphere(vec3(x, 0, sqrt(1. - x * x)) * yRotate,
                                   vec3(x, 0, -sqrt(1. - x * x)) * yRotate);

     cr1 = c1.z;
     cr2 = c2.z;
     cPos1 = c1.xy;
     cPos2 = c2.xy;
     if(y > cPos1.y){
       revCircle = true;
     }
     if(x > cPos2.x){
       revCircle2 = true;
     }

     vec4 intersection = circleIntersection(cPos1, cr1, cPos2, cr2);
     vec2 p1 = intersection.xy;
     vec2 p2 = intersection.zw;

     vec2 corner = p2;

     if(revCircle){
       corner = p1;
     }
     vec2 translate = corner;
     vec2 tile = corner * 2.;
     for(float i = 0. ; i < sampleNum ; i++){
       vec2 position = ( (gl_FragCoord.xy + rand2n(gl_FragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);

       position *= ( 2.2 + ( t * 8.));
       //position += vec2(cos(iGlobalTime), 0.3 * sin(iGlobalTime));

       int d = IIS(position);

       if(d == 0){
         sum += vec3(0.,0.,0.);
       }else{
         sum += texture2D(texture, abs( vec2( 1.) - (g_pos + translate) / tile)).rgb;
         continue;
         // if(mod(float(d), 2.) == 0.){
         //   if(outer){
         //     sum += hsv2rgb(vec3(0.4 + 0.02 * colCount, 1., 1.));
         //   }else{
         //     sum += hsv2rgb(vec3(0.02 * colCount, 1., 1.));
         //   }
         // }else{
         //   if(outer){
         //     sum += hsv2rgb(vec3(0.8 + 0.02 * colCount, 1., 1.));
         //   }else{
         //     sum += hsv2rgb(vec3(0.7 + 0.02 * colCount, 1., 1.));
         //   }
         // }
       }
     }
     gl_FragColor = vec4(sum/sampleNum, 1.);
   }
  </script>
  <script id="fs4" type="x-shader/x-fragment">
   precision mediump float;

   uniform float iGlobalTime;
   uniform vec2 iResolution;
   uniform vec2 camResolution;
   uniform sampler2D texture;

   vec2 rand2n(vec2 co, float sampleIndex) {
     vec2 seed = co * (sampleIndex + 1.0);
     seed+=vec2(-1,1);
     // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html
     return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),
                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));
   }


   vec2 cPos1 = vec2(1.2631, 0);
   vec2 cPos2 = vec2(0, 1.2631);
   float cr1 = 0.771643;
   float cr2 = 0.771643;
   const float PI = 3.14159265359;

   vec2 g_pos;

   vec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){
     return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;
   }

   vec2 reverseStereoProject(vec3 pos){
     return vec2(pos.x / (1. - pos.z), pos.y / (1. - pos.z));
   }


   vec3 getCircleFromSphere(vec3 upper, vec3 lower){
     vec2 p1 = reverseStereoProject(upper);
     vec2 p2 = reverseStereoProject(lower);
     return vec3((p1 + p2) / 2., distance(p1, p2)/ 2.);
   }

   bool revCircle = false;
   bool revCircle2 = false;
   const int ITERATIONS = 50;
   float colCount = 0.;
   bool outer = false;

   vec3 hsv2rgb(vec3 c)
   {
     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
   }

   const float sampleNum = 30.;
   void main( ){

     float t = mod(iGlobalTime, 10.);
     t = abs(t - 5.) / 5.;

     float ratio = iResolution.x / iResolution.y / 2.0;
     vec3 sum = vec3(0);
     float x = 0.57735;

     float bendX = t;// 0. + 1. * abs(sin(iGlobalTime));;//PI / 6.;
     mat3 xRotate = mat3(1, 0, 0,
                         0, cos(bendX), -sin(bendX),
                         0, sin(bendX), cos(bendX));
     float bendY = PI/6.5;//-abs(0.8 * sin(iGlobalTime));
     mat3 yRotate = mat3(cos(bendY), 0, sin(bendY),
                         0, 1, 0,
                         -sin(bendY), 0, cos(bendY));
     float y = .57735;
     vec3 c1 = getCircleFromSphere(vec3(0, y, sqrt(1. - y * y))* xRotate,
                                   vec3(0, y, -sqrt(1. - y * y))* xRotate);
     vec3 c2 = getCircleFromSphere(vec3(x, 0, sqrt(1. - x * x)) * yRotate,
                                   vec3(x, 0, -sqrt(1. - x * x)) * yRotate);

     cr1 = c1.z;
     cr2 = c2.z;
     cPos1 = c1.xy;
     cPos2 = c2.xy;
     if(y > cPos1.y){
       revCircle = true;
     }
     if(x > cPos2.x){
       revCircle2 = true;
     }

     vec2 translate = vec2(0, 0);
     vec2 tile = vec2(x, y) * 1.;

     for(float i = 0. ; i < sampleNum ; i++){
       vec2 position = ( (gl_FragCoord.xy + rand2n(gl_FragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);

       position *= ( 2.2 + ( t * 8.));
       position += translate;
       if(0. < position.x && position.x < x &&
          0. < position.y && position.y < y){
            sum += texture2D(texture, abs( vec2(0., 1.) - (position) / tile)).rgb;
          }
     }
     gl_FragColor = vec4(sum/sampleNum, 1.);
   }
  </script>

  <style>
   canvas {
     background-color: black;
   }
  </style>
</head>
<body>
  <canvas id="canvas" width="512" height="512"></canvas>
  <!-- <canvas id="canvas2" width="512" height="512"></canvas> -->
</body></html>
